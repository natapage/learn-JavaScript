// список долгов:

// что возвращают метод splice, sort
// долг в QA 105 - почему symbol.iterator в квадратных скобках
// глава про JSON
// new Function из qa 117 задание от Кирилла
// NFE  чем отличается обращение
// главы дескрипторы и геттеры, сеттеры
// 3 отличия классов от функции конструктора
// сделать транзишн на слайдер (сделано)
// главы 10.1-10.2
// в чайнике сделать переменные для 1500 ml, сделать подобие остывание (чтобы можно было запускать уже вскипяченый чайник снова) (сделано)
// метод Symbol в instanceOf синтаксис

// _______________________________________________________________________________________________________________

// что возвращают метод splice, sort
arr.sort(fn); //- сортирует на месте и возвращает себя ( возвращает this)

arr.splice(index, count, "добавить элемент"); // Возвращается массив, содержащий удалённые элементы.
//Если будет удалён только один элемент, вернётся массив из одного элемента.
//Если никакие элементы не будут удалены, вернётся пустой массив.

// _______________________________________________________________________________________________________________

// долг из QA 105 - почему symbol.iterator в квадратных скобках

// Существует множество системных символов, используемых внутри JavaScript, доступных как Symbol.*.
//  Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов.

// метод с именем Symbol.iterator - специальный встроенный Symbol (системный Symbol)
// метод Symbol.iterator это ключ объекта и поэтому он как и любой другой символ заключается в квадратные скобки
// _______________________________________________________________________________________________________________

// JSON (JavaScript Object Notation)
// JavaScript предоставляет методы:

// JSON.stringify для преобразования объектов в JSON.
// JSON.parse для преобразования JSON обратно в объект.

// Обратите внимание, что объект в формате JSON имеет несколько важных отличий от объектного литерала:

// Строки используют двойные кавычки. Никаких одинарных кавычек или обратных кавычек в JSON. Так 'John' становится "John".
// Имена свойств объекта также заключаются в двойные кавычки. Это обязательно. Так age:30 становится "age":30.

// JSON поддерживает следующие типы данных:

// Объекты { ... }
// Массивы [ ... ]
// Примитивы:
// строки,
// числа,
// логические значения true/false,
// null.

// Пропускает:

// Свойства-функции (методы).
// Символьные ключи и значения.
// Свойства, содержащие undefined.

// Если объект имеет метод toJSON, то он вызывается через JSON.stringify.

// Преобразуйте объект в JSON, а затем обратно в обычный объект
// Преобразуйте user в JSON, затем прочитайте этот JSON в другую переменную.

let user = {
  name: "Василий Иванович",
  age: 35,
};

let json = JSON.parse(JSON.stringify(user));

// Исключить обратные ссылки
// В простых случаях циклических ссылок мы можем исключить свойство, из-за которого они возникают, из сериализации по его имени.
// Но иногда мы не можем использовать имя, так как могут быть и другие, нужные, свойства с этим именем во вложенных объектах. Поэтому можно проверять свойство по значению.
// Напишите функцию replacer для JSON-преобразования, которая удалит свойства, ссылающиеся на meetup:

let room = {
  number: 23,
};

let meetup = {
  title: "Совещание",
  occupiedBy: [{ name: "Иванов" }, { name: "Петров" }],
  place: room,
};

// цикличные ссылки
room.occupiedBy = meetup;
meetup.self = meetup;

alert(
  JSON.stringify(meetup, function replacer(key, value) {
    /* ваш код */
  })
);

/* в результате должно быть:
{
  "title":"Совещание",
  "occupiedBy":[{"name":"Иванов"},{"name":"Петров"}],
  "place":{"number":23}
}
*/

let room = {
  number: 23,
};

let meetup = {
  title: "Совещание",
  occupiedBy: [{ name: "Иванов" }, { name: "Петров" }],
  place: room,
};

room.occupiedBy = meetup;
meetup.self = meetup;

alert(
  JSON.stringify(meetup, function replacer(key, value) {
    return key != "" && value == meetup ? undefined : value;
  })
);

// _________________________________________________________________________________________________________________________

//NFE  зачем даётся имя?

let sayHi = function func(who) {
  alert(`Hello, ${who}`);
};

sayHi("John"); // Hello, John

// Есть две важные особенности имени func, ради которого оно даётся:

// Оно позволяет функции ссылаться на себя же.
// Оно не доступно за пределами функции.

// ________________________________________________________________________________________________________________________

// 3 отличия классов от функции конструктора

// 1. Во-первых, функция, созданная с помощью class, помечена специальным внутренним свойством [[IsClassConstructor]]: true. Поэтому это не совсем то же самое, что создавать её вручную.

// В отличие от обычных функций, конструктор класса не может быть вызван без new:

// 2. Методы класса являются неперечислимыми. Определение класса устанавливает флаг enumerable вfalse для всех методов в "prototype".

// 3. И это хорошо, так как если мы проходимся циклом for..in по объекту, то обычно мы не хотим при этом получать методы класса.

// Классы всегда используют use strict. Весь код внутри класса автоматически находится в строгом режиме.

// ________________________________________________________________________________________________________________________

//  метод Symbol в instanceOf синтаксис

// Алгоритм работы obj instanceof Class работает примерно так:

// Если имеется статический метод Symbol.hasInstance, тогда вызвать его:
// Class[Symbol.hasInstance](obj). Он должен вернуть либо true, либо false, и это конец.
//  Это как раз и есть возможность ручной настройки instanceof.
// ________________________________________________________________________________________________________________________

// главы 10.1-10.2

// Обработка ошибок, "try..catch"
// Пользовательские ошибки, расширение Error

// _________________________________________________________________________________________________________________________

// главы дескрипторы и геттеры, сеттеры (просто не отвечала)

// Его синтаксис:

// // let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);

// writable – если true, свойство можно изменить, иначе оно только для чтения.
// enumerable – если true, свойство перечисляется в циклах, в противном случае циклы его игнорируют.
// configurable – если true, свойство можно удалить, а эти атрибуты можно изменять, иначе этого делать нельзя.

// Чтобы изменить флаги, мы можем использовать метод Object.defineProperty.

// Его синтаксис:
// Object.defineProperty(obj, propertyName, descriptor)

// Существует метод Object.defineProperties(obj, descriptors), который позволяет определять множество свойств сразу.

// Object.getOwnPropertyDescriptors
// Чтобы получить все дескрипторы свойств сразу, можно воспользоваться методом Object.getOwnPropertyDescriptors(obj).
