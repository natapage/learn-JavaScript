////////////////////////////////////   var  ///////////////////////////////////////

// Существует 2 основных отличия var от let/const:

// Переменные var не имеют блочной области видимости, они ограничены, как минимум, телом функции.
// Объявления (инициализация) переменных varпроизводится в начале исполнения функции (или скрипта для глобальных переменных).
// Есть ещё одно небольшое отличие, относящееся к глобальному объекту, мы рассмотрим его в следующей главе.

// Эти особенности, как правило, не очень хорошо влияют на код. Блочная область видимости – это удобно.

function sayHi() {
  if (true) {
    var phrase = "Привет";
  }

  alert(phrase); // срабатывает и выводит "Привет"
}

////////////////////////////////////   global-object  ///////////////////////////////////////

// Глобальный объект хранит переменные, которые должны быть доступны в любом месте программы.

// Это включает в себя как встроенные объекты, например, Array, так и характерные для окружения свойства, например,
// window.innerHeight – высота окна браузера.

// Глобальный объект имеет универсальное имя – globalThis.

// …Но чаще на него ссылаются по-старому, используя имя, характерное для данного окружения, такое как window (браузер) и global (Node.js).

// Следует хранить значения в глобальном объекте, только если они действительно глобальны для нашего проекта.
// И стараться свести их количество к минимуму.

// В браузерах, если только мы не используем модули, глобальные функции и переменные, объявленные с помощью var,
// становятся свойствами глобального объекта.

// Для того, чтобы код был проще и в будущем его легче было поддерживать,
// следует обращаться к свойствам глобального объекта напрямую, как window.x.

// Ко всем свойствам глобального объекта можно обращаться напрямую:

alert("Привет");
// это то же самое, что и
window.alert("Привет");

////////////////////////////////////   function-object  ///////////////////////////////////////

// Установка и уменьшение значения счётчика
// Измените код makeCounter() так, чтобы счётчик мог уменьшать и устанавливать значение:

// counter() должен возвращать следующее значение (как и раньше).
// counter.set(value) должен устанавливать счётчику значение value.
// counter.decrease() должен уменьшать значение счётчика на 1.
// Посмотрите код из песочницы с полным примером использования.

// P.S. Для того, чтобы сохранить текущее значение счётчика, можно воспользоваться как замыканием,
// так и свойством функции. Или сделать два варианта решения: и так, и так.

function makeCounter() {
  let count = 0;

  function counter() {
    return count++;
  }

  counter.set = function (value) {
    count = value;
  };

  counter.decrease = function () {
    count--;
  };

  return counter;
}

let counter = makeCounter();

alert(counter()); // 0
alert(counter()); // 1

counter.set(10); // установить новое значение счётчика

alert(counter()); // 10

counter.decrease(); // уменьшить значение счётчика на 1

alert(counter()); // 10 (вместо 11)

// _____________________________________________________________________________________________________________________________________

// Сумма с произвольным количеством скобок
// Напишите функцию sum, которая бы работала следующим образом:

sum(1)(2) == 3; // 1 + 2
sum(1)(2)(3) == 6; // 1 + 2 + 3
sum(5)(-1)(2) == 6;
sum(6)(-1)(-2)(-3) == 0;
sum(0)(1)(2)(3)(4)(5) == 15;

// P.S. Подсказка: возможно вам стоит сделать особый метод преобразования в примитив для функции.

function sum(first) {
  let total = first;

  function next(n) {
    total += n;
    return next;
  }
  next.valueOf = function () {
    return total;
  };
  return next;
}
