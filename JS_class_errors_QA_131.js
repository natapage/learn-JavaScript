// Странный instanceof
// Почему instanceof в примере ниже возвращает true? Мы же видим, что a не создан с помощью B().

function A() {}
function B() {}

A.prototype = B.prototype = {};

let a = new A();

alert(a instanceof B); // true

// тк одинаковая ссылка на прототип
// a.__proto__ == B.prototype

// ____________________________________________________________________________

// Finally или просто код?
// Сравните два фрагмента кода.

// Первый использует finally для выполнения кода после try..catch:

// try {
//   начать работу
//   работать
// } catch (e) {
//   обработать ошибку
// } finally {
//   очистить рабочее пространство
// }

// Второй фрагмент просто ставит очистку после try..catch:

// try {
//   начать работу
//   работать
// } catch (e) {
//   обработать ошибку
// }

// очистить рабочее пространство

// Нам определённо нужна очистка после работы, неважно возникли ошибки или нет.

// Есть ли здесь преимущество в использовании finally или оба фрагмента кода одинаковы? Если такое преимущество есть, то дайте пример, когда оно проявляется.

// ____________________________________________________________________________

// Наследование от SyntaxError
// Создайте класс FormatError, который наследует от встроенного класса SyntaxError.

// Класс должен поддерживать свойства message, name и stack.

// Пример использования:

let err = new FormatError("ошибка форматирования");

alert(err.message); // ошибка форматирования
alert(err.name); // FormatError
alert(err.stack); // stack

alert(err instanceof FormatError); // true
alert(err instanceof SyntaxError); // true (потому что наследует от SyntaxError)
